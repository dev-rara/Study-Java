## 정렬

### 정렬이란?
* 특정 값을 기준으로 데이터를 순서대로 배치하는 방법
* 구현 난이도는 쉽지만 속도는 느린 알고리즘
  * 버블 정렬, 삽입 정렬, 선택 정렬
* 구현 난이도는 조금 더 어렵지만 속도는 빠른 알고리즘
  * 합병 정렬, 힙 정렬, 퀵 정렬, 트리 정렬
* 하이브리드 정렬
  * 팀 정렬, 블록 병합 정렬, 인트로 정렬
* 기타 정렬 알고리즘
  * 기수 정렬, 카운팅 정렬, 셸 정렬, 보고 정렬

###
### 정렬(1)
#### 버블 정렬(Bubble Sort)
* 인접한 데이터를 비교하며 자리 바꾸는 방식
* 만들기 쉽고 직관적이지만 알고리즘적 관점에서 보면 비효율적인 정렬 방식
* 알고리즘 복잡도: O(n^2);  



#### 삽입 정렬(Insertion Sort)
* 앞의 데이터를 정렬 해가면서 삽입 위치를 찾아 정렬하는 방식
* 평균적으로는 O(n^2) 중 빠른 편이나 최악의 경우는 느리다
* 알고리즘 복잡도: O(n^2)  
  
 


#### 선택 정렬(Selection Sort)
* 최소 또는 최대 값을 찾아서 가장 앞 또는 뒤부터 정렬하는 방식
* 알고리즘 복잡도: O(n^2)  
  


###
### 정렬(2)
#### 합병 정렬(Merge Sort)
* 배열을 계속 분할해서 길이가 1이 되도록 만들고, 인접한 부분끼리 정렬하면서 합병하는 방식
* 데이터 크기만한 메모리가 더 필요하지만 같은 값의 앞뒤가 순서가 바뀌지 않는 것이 최대 장점이다
* 알고리즘 복잡도: O(nlogn)  
  
    

        
#### 힙 정렬(Heap Sort)
* 힙 자료구조 형태의 정렬 방식
* 기존 배열을 최대 힙으로 구조 변경 후 정렬 진행
* 알고리즘 복잡도: O(nlon)  

  
  
  
#### 퀵 정렬(Quick Sort)
* 임의의 기준 값을 정하고 그 값을 기준으로 좌우로 분할하며 정렬하는 방식
* 알고리즘 복잡도: O(n^2)  
  
  
###
### 정렬(3)
#### 기수 정렬(radix Sort)
* 낮은 자리 수부터 정렬하는 방식
* 각 원소 간의 비교 연산을 하지 않아 정렬 속도가 빠른 대신, 기수 테이블을 위한 메모리 필요
* 알고리즘 복잡도 O(dn)  -> d: 최대 자릿수  
  
  
  
  
#### 계수 정렬(counting Sort)
* 숫자 끼리 비교하지 않고 카운트를 세서 정렬하는 방식
* 카운팅을 위한 메모리 필요
* 알고리즘 복잡도 O(n + k)  -> k: 정렬 대상 데이터 중 최대 값  
  
  
  
  
#### 셸 정렬(shell Sort)
* 삽입 정렬의 약점 보완한 정렬 방식
* 삽입 정렬의 약점
  * 오름차순 정렬 기준, 내림차순으로 구성된 데이터에 대해서는 앞의 데이터와 하나씩 비교하며 모두 교환 필요
* 이전의 모든 데이터와 비교하지 않고 일정 간격을 두어 비교
* 알고리즘 복잡도: O(n^2)
  * 간격 설정에 따라 Worst case는 삽입 정렬과 동일
  * 일반적인 산포 데이터 기준으로는 삽입 정렬에 비해 빠르다  
  
  

